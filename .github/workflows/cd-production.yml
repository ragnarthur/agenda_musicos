name: CD Production

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      mode:
        description: "Acao remota no servidor"
        required: true
        default: "deploy"
        type: choice
        options:
          - deploy
          - status
          - seed-test-data
          - load-test

permissions:
  contents: read

concurrency:
  group: cd-production
  cancel-in-progress: false

jobs:
  deploy:
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    runs-on: [self-hosted, prod-server]
    timeout-minutes: 60
    environment: production
    steps:
      - name: Definir diretorio da aplicacao
        shell: bash
        run: |
          set -euo pipefail
          APP_DIR="${{ secrets.PROD_APP_DIR }}"
          if [ -z "${APP_DIR:-}" ]; then
            APP_DIR="/opt/agenda-musicos/agenda_musicos"
          fi
          [ -d "$APP_DIR" ] || { echo "Diretorio da app nao existe: $APP_DIR"; exit 1; }
          echo "APP_DIR=$APP_DIR" >> "$GITHUB_ENV"

      - name: Mostrar contexto do disparo
        shell: bash
        run: |
          echo "event_name=$GITHUB_EVENT_NAME"
          echo "runner_name=$RUNNER_NAME"
          echo "runner_os=$RUNNER_OS"
          if [ "$GITHUB_EVENT_NAME" = "workflow_run" ]; then
            echo "ci_conclusion=${{ github.event.workflow_run.conclusion }}"
            echo "ci_head_sha=${{ github.event.workflow_run.head_sha }}"
            echo "ci_head_branch=${{ github.event.workflow_run.head_branch }}"
          else
            echo "manual_mode=${{ github.event.inputs.mode }}"
          fi

      - name: Executar deploy remoto
        if: github.event_name == 'workflow_run' || (github.event_name == 'workflow_dispatch' && github.event.inputs.mode == 'deploy')
        shell: bash
        run: |
          set -euo pipefail
          cd "$APP_DIR"
          if command -v timeout >/dev/null 2>&1; then
            timeout --foreground 20m ./deploy.sh deploy
          else
            ./deploy.sh deploy
          fi

      - name: Seed dados de teste (load test users)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.mode == 'seed-test-data'
        shell: bash
        run: |
          set -euo pipefail
          cd "$APP_DIR"
          docker compose --env-file .env.prod -f docker-compose.prod.yml exec -T backend \
            python manage.py seed_test_data

      - name: Executar load test (interno - bypass nginx via Docker)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.mode == 'load-test'
        shell: bash
        run: |
          set -euo pipefail
          cd "$APP_DIR"

          # Verificar conectividade direta com o backend via Docker exec (sem sair da rede interna)
          docker compose --env-file .env.prod -f docker-compose.prod.yml \
            exec -T backend python -c \
            "import urllib.request, sys; r=urllib.request.urlopen('http://localhost:8000/healthz/',timeout=5); print('Backend acessivel via exec OK, status:', r.status)" \
            || { echo "Backend nao respondeu ao healthz"; exit 1; }

          # Garantir que usuario de teste existe
          echo "Criando/verificando usuario de teste livia_vocal..."
          docker compose --env-file .env.prod -f docker-compose.prod.yml \
            exec -T backend python manage.py seed_test_data
          echo "Usuario de teste OK"

          # Resolver IP do nginx na rede interna para rotear trafego via HTTPS
          # (cookies JWT usam flag Secure e exigem HTTPS; nginx faz SSL termination)
          # O nginx agora tem geo block que isenta 172.16.0.0/12 de rate limiting
          NGINX_CONTAINER=$(docker compose --env-file .env.prod -f docker-compose.prod.yml ps -q nginx)
          NGINX_IP=$(docker inspect "$NGINX_CONTAINER" --format '{{(index .NetworkSettings.Networks "agenda_musicos_internal").IPAddress}}')
          DOMAIN="${{ secrets.PROD_DOMAIN }}"
          if [ -z "${DOMAIN:-}" ]; then DOMAIN="gigflowagenda.com.br"; fi
          echo "[load-test] nginx IP=${NGINX_IP} domain=${DOMAIN}"

          RESULT_DIR="$APP_DIR/load_tests/results"
          mkdir -p "$RESULT_DIR"
          chmod 777 "$RESULT_DIR"
          STAMP=$(date +%Y%m%d-%H%M%S)

          # Locust via Docker na rede interna:
          # --add-host mapeia dominio para IP interno do nginx (HTTPS, sem rate-limit para 172.x)
          # Cookies JWT Secure funcionam via HTTPS; nginx geo block isenta rede Docker de throttle
          run_phase() {
            local label="$1" users="$2" spawn_rate="$3" runtime="$4"
            local csv_prefix="load_tests/results/${STAMP}-${label}"
            echo ""
            echo "=== [load-test] fase=${label} users=${users} runtime=${runtime} ==="
            docker run --rm \
              --network agenda_musicos_internal \
              --add-host "${DOMAIN}:${NGINX_IP}" \
              -v "$APP_DIR:/app" \
              -w /app \
              -e "LOCUST_HOST=https://${DOMAIN}" \
              -e LOCUST_WEIGHT_AUTH=0 \
              locustio/locust:2.39.1 \
              -f load_tests/locustfile.py \
              --headless \
              --users "$users" \
              --spawn-rate "$spawn_rate" \
              --run-time "$runtime" \
              --print-stats \
              --csv "$csv_prefix" \
              --host "https://${DOMAIN}"
            echo "[load-test] aguardando 10s antes da proxima fase..."
            sleep 10
          }

          # spawn_rate=0.4/s = 24/min (DRF throttle login=30/min por IP)
          # Cada fase tem runtime suficiente para spawnar todos os users antes do steady state

          # Fase 1: ramp-up ate 100 (100/0.4=250s ramp + 110s steady = 360s=6m)
          run_phase "f1-ramp-100"   100  0.4  6m
          # Fase 2: 100 constante (steady state)
          run_phase "f2-const-100"  100  0.4  5m
          # Fase 3: ramp-up ate 300 (200 novos / 0.4 = 500s ramp + 100s steady = 600s=10m)
          run_phase "f3-ramp-300"   300  0.4  10m
          # Fase 4: 300 constante
          run_phase "f4-const-300"  300  0.4  5m
          # Fase 5: breakpoint incremental (200 novos por fase = 500s ramp + 100s steady = 10m)
          for users in 500 700 900; do
            run_phase "f5-break-${users}" "$users" 0.4 10m || {
              echo "[load-test] BREAKPOINT atingido em ${users} usuarios."; break
            }
          done

          echo ""
          echo "=== RESUMO DO LOAD TEST ==="
          for csv in "${RESULT_DIR}/${STAMP}"*_stats.csv; do
            [ -f "$csv" ] || continue
            echo "--- $(basename "$csv") ---"
            python3 - "$csv" <<'PY'
          import csv, sys
          rows = list(csv.DictReader(open(sys.argv[1])))
          agg = next((r for r in rows if r["Name"] == "Aggregated"), None)
          if agg:
              total = int(agg["Request Count"])
              fails = int(agg["Failure Count"])
              pct   = fails / max(total, 1) * 100
              print(f"  Requests: {total} | Failures: {fails} ({pct:.1f}%)")
              print(f"  Avg: {float(agg['Average Response Time']):.0f}ms | P50: {agg['50%']}ms | P95: {agg['95%']}ms | P99: {agg['99%']}ms")
              print(f"  RPS: {float(agg['Requests/s']):.1f}")
          PY
          done
          echo "==========================="

      - name: Consultar status remoto
        if: github.event_name == 'workflow_run' || (github.event_name == 'workflow_dispatch' && github.event.inputs.mode == 'status')
        shell: bash
        run: |
          set -euo pipefail
          cd "$APP_DIR"
          if command -v timeout >/dev/null 2>&1; then
            timeout --foreground 3m ./deploy.sh status
          else
            ./deploy.sh status
          fi

      - name: Validar healthz e readyz
        shell: bash
        run: |
          set -euo pipefail
          DOMAIN="${{ secrets.PROD_DOMAIN }}"
          if [ -z "${DOMAIN:-}" ]; then
            DOMAIN="gigflowagenda.com.br"
          fi
          API_DOMAIN="${{ secrets.PROD_API_DOMAIN }}"
          if [ -z "${API_DOMAIN:-}" ]; then
            API_DOMAIN="api.${DOMAIN}"
          fi

          check_url () {
            local url="$1"
            local label="$2"
            local host="$3"
            local attempts=10
            local wait_seconds=5
            local code="000"

            echo "Validando ${label}: ${url}"
            for i in $(seq 1 "$attempts"); do
              code=$(curl -sS -o /dev/null -w "%{http_code}" --connect-timeout 3 --max-time 8 --resolve "${host}:443:127.0.0.1" "$url" || echo "000")
              if [ "$code" = "200" ]; then
                echo "${label} OK (200)"
                return 0
              fi
              echo "Tentativa ${i}/${attempts} => HTTP ${code}"
              sleep "$wait_seconds"
            done

            echo "Falha ao validar ${label}. Ultimo status: ${code}"
            return 1
          }

          check_url "https://${DOMAIN}/healthz/" "healthz" "${DOMAIN}"
          check_url "https://${DOMAIN}/api/readyz/" "readyz-main-domain" "${DOMAIN}"
          check_url "https://${API_DOMAIN}/api/readyz/" "readyz-api-domain" "${API_DOMAIN}"

      - name: Verificacao final da stack
        shell: bash
        run: |
          set -euo pipefail
          cd "$APP_DIR"
          docker compose --env-file .env.prod -f docker-compose.prod.yml ps

      - name: Coletar diagnostico em falha
        if: failure()
        shell: bash
        run: |
          set +e
          cd "$APP_DIR"
          echo "== docker compose ps =="
          docker compose --env-file .env.prod -f docker-compose.prod.yml ps
          echo "== ultimos logs (backend/frontend/nginx) =="
          docker compose --env-file .env.prod -f docker-compose.prod.yml logs --tail=120 backend frontend nginx
